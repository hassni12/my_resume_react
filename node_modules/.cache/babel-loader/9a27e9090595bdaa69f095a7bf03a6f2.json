{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar animateStyle = require('./animate-style.cjs.js');\n\nvar options = require('./utils/options.cjs.js');\n\nvar resolveElements = require('../utils/resolve-elements.cjs.js');\n\nvar controls = require('./utils/controls.cjs.js');\n\nvar stagger = require('../utils/stagger.cjs.js');\n\nfunction animate(elements, keyframes, options$1 = {}) {\n  elements = resolveElements.resolveElements(elements);\n  const numElements = elements.length;\n  /**\n   * Create and start new animations\n   */\n\n  const animationFactories = [];\n\n  for (let i = 0; i < numElements; i++) {\n    const element = elements[i];\n\n    for (const key in keyframes) {\n      const valueOptions = options.getOptions(options$1, key);\n      valueOptions.delay = stagger.resolveOption(valueOptions.delay, i, numElements);\n      const animation = animateStyle.animateStyle(element, key, keyframes[key], valueOptions);\n      animationFactories.push(animation);\n    }\n  }\n\n  return controls.withControls(animationFactories, options$1,\n  /**\n   * TODO:\n   * If easing is set to spring or glide, duration will be dynamically\n   * generated. Ideally we would dynamically generate this from\n   * animation.effect.getComputedTiming().duration but this isn't\n   * supported in iOS13 or our number polyfill. Perhaps it's possible\n   * to Proxy animations returned from animateStyle that has duration\n   * as a getter.\n   */\n  options$1.duration);\n}\n\nexports.animate = animate;","map":null,"metadata":{},"sourceType":"script"}