{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar tslib = require('tslib');\n\nvar heyListen = require('hey-listen');\n\nvar utils = require('@motionone/utils');\n\nvar animateStyle = require('../animate/animate-style.cjs.js');\n\nvar style = require('../animate/style.cjs.js');\n\nvar options = require('../animate/utils/options.cjs.js');\n\nvar hasChanged = require('./utils/has-changed.cjs.js');\n\nvar resolveVariant = require('./utils/resolve-variant.cjs.js');\n\nvar schedule = require('./utils/schedule.cjs.js');\n\nvar inView = require('./gestures/in-view.cjs.js');\n\nvar hover = require('./gestures/hover.cjs.js');\n\nvar press = require('./gestures/press.cjs.js');\n\nvar events = require('./utils/events.cjs.js');\n\nconst gestures = {\n  inView: inView.inView,\n  hover: hover.hover,\n  press: press.press\n};\n/**\n * A list of state types, in priority order. If a value is defined in\n * a righter-most type, it will override any definition in a lefter-most.\n */\n\nconst stateTypes = [\"initial\", \"animate\", ...Object.keys(gestures), \"exit\"];\n/**\n * A global store of all generated motion states. This can be used to lookup\n * a motion state for a given Element.\n */\n\nconst mountedStates = new WeakMap();\n\nfunction createMotionState(options$1 = {}, parent) {\n  /**\n   * The element represented by the motion state. This is an empty reference\n   * when we create the state to support SSR and allow for later mounting\n   * in view libraries.\n   *\n   * @ts-ignore\n   */\n  let element;\n  /**\n   * Calculate a depth that we can use to order motion states by tree depth.\n   */\n\n  let depth = parent ? parent.getDepth() + 1 : 0;\n  /**\n   * Track which states are currently active.\n   */\n\n  const activeStates = {\n    initial: true,\n    animate: true\n  };\n  /**\n   * A map of functions that, when called, will remove event listeners for\n   * a given gesture.\n   */\n\n  const gestureSubscriptions = {};\n  /**\n   * Initialise a context to share through motion states. This\n   * will be populated by variant names (if any).\n   */\n\n  const context = {};\n\n  for (const name of stateTypes) {\n    context[name] = typeof options$1[name] === \"string\" ? options$1[name] : parent === null || parent === void 0 ? void 0 : parent.getContext()[name];\n  }\n  /**\n   * If initial is set to false we use the animate prop as the initial\n   * animation state.\n   */\n\n\n  const initialVariantSource = options$1.initial === false ? \"animate\" : \"initial\";\n  /**\n   * Destructure an initial target out from the resolved initial variant.\n   */\n\n  let _a = resolveVariant.resolveVariant(options$1[initialVariantSource] || context[initialVariantSource], options$1.variants) || {},\n      target = tslib.__rest(_a, [\"transition\"]);\n  /**\n   * The base target is a cached map of values that we'll use to animate\n   * back to if a value is removed from all active state types. This\n   * is usually the initial value as read from the DOM, for instance if\n   * it hasn't been defined in initial.\n   */\n\n\n  const baseTarget = Object.assign({}, target);\n  /**\n   * A generator that will be processed by the global animation scheduler.\n   * This yeilds when it switches from reading the DOM to writing to it\n   * to prevent layout thrashing.\n   */\n\n  function* animateUpdates() {\n    var _a, _b;\n\n    const prevTarget = target;\n    target = {};\n    const animationOptions = {};\n\n    for (const name of stateTypes) {\n      if (!activeStates[name]) continue;\n      const variant = resolveVariant.resolveVariant(options$1[name]);\n      if (!variant) continue;\n\n      for (const key in variant) {\n        if (key === \"transition\") continue;\n        target[key] = variant[key];\n        animationOptions[key] = options.getOptions((_b = (_a = variant.transition) !== null && _a !== void 0 ? _a : options$1.transition) !== null && _b !== void 0 ? _b : {}, key);\n      }\n    }\n\n    const allTargetKeys = new Set([...Object.keys(target), ...Object.keys(prevTarget)]);\n    const animationFactories = [];\n    allTargetKeys.forEach(key => {\n      var _a;\n\n      if (target[key] === undefined) {\n        target[key] = baseTarget[key];\n      }\n\n      if (hasChanged.hasChanged(prevTarget[key], target[key])) {\n        (_a = baseTarget[key]) !== null && _a !== void 0 ? _a : baseTarget[key] = style.style.get(element, key);\n        animationFactories.push(animateStyle.animateStyle(element, key, target[key], animationOptions[key]));\n      }\n    }); // Wait for all animation states to read from the DOM\n\n    yield;\n    const animations = animationFactories.map(factory => factory()).filter(Boolean);\n    if (!animations.length) return;\n    const animationTarget = target;\n    element.dispatchEvent(events.motionEvent(\"motionstart\", animationTarget));\n    Promise.all(animations.map(animation => animation.finished)).then(() => {\n      element.dispatchEvent(events.motionEvent(\"motioncomplete\", animationTarget));\n    }).catch(utils.noop);\n  }\n\n  const setGesture = (name, isActive) => () => {\n    activeStates[name] = isActive;\n    schedule.scheduleAnimation(state);\n  };\n\n  const updateGestureSubscriptions = () => {\n    for (const name in gestures) {\n      const isGestureActive = gestures[name].isActive(options$1);\n      const remove = gestureSubscriptions[name];\n\n      if (isGestureActive && !remove) {\n        gestureSubscriptions[name] = gestures[name].subscribe(element, {\n          enable: setGesture(name, true),\n          disable: setGesture(name, false)\n        }, options$1);\n      } else if (!isGestureActive && remove) {\n        remove();\n        delete gestureSubscriptions[name];\n      }\n    }\n  };\n\n  const state = {\n    update: newOptions => {\n      if (!element) return;\n      options$1 = newOptions;\n      updateGestureSubscriptions();\n      schedule.scheduleAnimation(state);\n    },\n    setActive: (name, isActive) => {\n      if (!element) return;\n      activeStates[name] = isActive;\n      schedule.scheduleAnimation(state);\n    },\n    animateUpdates,\n    getDepth: () => depth,\n    getTarget: () => target,\n    getOptions: () => options$1,\n    getContext: () => context,\n    mount: newElement => {\n      heyListen.invariant(Boolean(newElement), \"Animation state must be mounted with valid Element\");\n      element = newElement;\n      mountedStates.set(element, state);\n      updateGestureSubscriptions();\n      return () => {\n        mountedStates.delete(element);\n        schedule.unscheduleAnimation(state);\n\n        for (const key in gestureSubscriptions) {\n          gestureSubscriptions[key]();\n        }\n      };\n    },\n    isMounted: () => Boolean(element)\n  };\n  return state;\n}\n\nexports.createMotionState = createMotionState;\nexports.mountedStates = mountedStates;","map":null,"metadata":{},"sourceType":"script"}