{"ast":null,"code":"import { visualElement } from '../index.mjs';\nimport { getOrigin, checkTargetForNewValues } from '../utils/setters.mjs';\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\nimport { isCSSVariable } from '../dom/utils/is-css-variable.mjs';\nimport { parseDomVariant } from '../dom/utils/parse-dom-variant.mjs';\nimport { transformProps } from './utils/transform.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\nimport { renderHTML } from './utils/render.mjs';\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\nimport { measureViewportBox } from '../../projection/utils/measure.mjs';\n\nfunction getComputedStyle(element) {\n  return window.getComputedStyle(element);\n}\n\nconst htmlConfig = {\n  treeType: \"dom\",\n\n  readValueFromInstance(domElement, key) {\n    if (transformProps.has(key)) {\n      const defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    } else {\n      const computedStyle = getComputedStyle(domElement);\n      const value = (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n      return typeof value === \"string\" ? value.trim() : value;\n    }\n  },\n\n  sortNodePosition(a, b) {\n    /**\n     * compareDocumentPosition returns a bitmask, by using the bitwise &\n     * we're returning true if 2 in that bitmask is set to true. 2 is set\n     * to true if b preceeds a.\n     */\n    return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n  },\n\n  getBaseTarget(props, key) {\n    var _a;\n\n    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n  },\n\n  measureViewportBox(element, {\n    transformPagePoint\n  }) {\n    return measureViewportBox(element, transformPagePoint);\n  },\n\n  /**\n   * Reset the transform on the current Element. This is called as part\n   * of a batched process across the entire layout tree. To remove this write\n   * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n   * works\n   */\n  resetTransform(element, domElement, props) {\n    const transformTemplate = props.transformTemplate;\n    domElement.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\"; // Ensure that whatever happens next, we restore our transform on the next frame\n\n    element.scheduleRender();\n  },\n\n  restoreTransform(instance, mutableState) {\n    instance.style.transform = mutableState.style.transform;\n  },\n\n  removeValueFromRenderState(key, {\n    vars,\n    style\n  }) {\n    delete vars[key];\n    delete style[key];\n  },\n\n  /**\n   * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n   * can be animated by Motion.\n   */\n  makeTargetAnimatable(element, {\n    transition,\n    transitionEnd,\n    ...target\n  }, {\n    transformValues\n  }, isMounted = true) {\n    let origin = getOrigin(target, transition || {}, element);\n    /**\n     * If Framer has provided a function to convert `Color` etc value types, convert them\n     */\n\n    if (transformValues) {\n      if (transitionEnd) transitionEnd = transformValues(transitionEnd);\n      if (target) target = transformValues(target);\n      if (origin) origin = transformValues(origin);\n    }\n\n    if (isMounted) {\n      checkTargetForNewValues(element, target, origin);\n      const parsed = parseDomVariant(element, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n\n    return {\n      transition,\n      transitionEnd,\n      ...target\n    };\n  },\n\n  scrapeMotionValuesFromProps,\n\n  build(element, renderState, latestValues, options, props) {\n    if (element.isVisible !== undefined) {\n      renderState.style.visibility = element.isVisible ? \"visible\" : \"hidden\";\n    }\n\n    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n  },\n\n  render: renderHTML\n};\nconst htmlVisualElement = visualElement(htmlConfig);\nexport { getComputedStyle, htmlConfig, htmlVisualElement };","map":null,"metadata":{},"sourceType":"module"}