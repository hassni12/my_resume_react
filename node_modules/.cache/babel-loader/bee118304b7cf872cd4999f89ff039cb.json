{"ast":null,"code":"import _slicedToArray from \"/home/hassnain/MERN_APP/RESUME_WEBSITE/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { invariant } from 'hey-listen';\n\nfunction isCSSVariable(value) {\n  return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\n\n\nconst cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\n\nfunction parseCSSVariable(current) {\n  const match = cssVariableRegex.exec(current);\n  if (!match) return [,];\n\n  const _match = _slicedToArray(match, 3),\n        token = _match[1],\n        fallback = _match[2];\n\n  return [token, fallback];\n}\n\nconst maxDepth = 4;\n\nfunction getVariableValue(current, element, depth = 1) {\n  invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\".concat(current, \"\\\". This may indicate a circular fallback dependency.\"));\n\n  const _parseCSSVariable = parseCSSVariable(current),\n        _parseCSSVariable2 = _slicedToArray(_parseCSSVariable, 2),\n        token = _parseCSSVariable2[0],\n        fallback = _parseCSSVariable2[1]; // No CSS variable detected\n\n\n  if (!token) return; // Attempt to read this CSS variable off the element\n\n  const resolved = window.getComputedStyle(element).getPropertyValue(token);\n\n  if (resolved) {\n    return resolved.trim();\n  } else if (isCSSVariable(fallback)) {\n    // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\n\n\nfunction resolveCSSVariables(visualElement, { ...target\n}, transitionEnd) {\n  const element = visualElement.getInstance();\n  if (!(element instanceof Element)) return {\n    target,\n    transitionEnd\n  }; // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n  // only if they change but I think this reads clearer and this isn't a performance-critical path.\n\n  if (transitionEnd) {\n    transitionEnd = { ...transitionEnd\n    };\n  } // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n\n\n  visualElement.forEachValue(value => {\n    const current = value.get();\n    if (!isCSSVariable(current)) return;\n    const resolved = getVariableValue(current, element);\n    if (resolved) value.set(resolved);\n  }); // Cycle through every target property and resolve CSS variables. Currently\n  // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n\n  for (const key in target) {\n    const current = target[key];\n    if (!isCSSVariable(current)) continue;\n    const resolved = getVariableValue(current, element);\n    if (!resolved) continue; // Clone target if it hasn't already been\n\n    target[key] = resolved; // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n    // CSS variable. This will ensure that after the animation the component will reflect\n    // changes in the value of the CSS variable.\n\n    if (transitionEnd && transitionEnd[key] === undefined) {\n      transitionEnd[key] = current;\n    }\n  }\n\n  return {\n    target,\n    transitionEnd\n  };\n}\n\nexport { cssVariableRegex, parseCSSVariable, resolveCSSVariables };","map":null,"metadata":{},"sourceType":"module"}