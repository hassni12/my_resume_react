{"ast":null,"code":"import { time } from '@motionone/utils';\nimport { calcGeneratorVelocity } from '../utils/velocity.es.js';\nimport { spring } from '../spring/index.es.js';\n\nconst glide = ({\n  from = 0,\n  velocity = 0.0,\n  power = 0.8,\n  decay = 0.325,\n  bounceDamping,\n  bounceStiffness,\n  changeTarget,\n  min,\n  max,\n  restDistance = 0.5,\n  restSpeed\n}) => {\n  decay = time.ms(decay);\n  const state = {\n    hasReachedTarget: false,\n    done: false,\n    current: from,\n    target: from\n  };\n\n  const isOutOfBounds = v => min !== undefined && v < min || max !== undefined && v > max;\n\n  const nearestBoundary = v => {\n    if (min === undefined) return max;\n    if (max === undefined) return min;\n    return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n  };\n\n  let amplitude = power * velocity;\n  const ideal = from + amplitude;\n  const target = changeTarget === undefined ? ideal : changeTarget(ideal);\n  state.target = target;\n  /**\n   * If the target has changed we need to re-calculate the amplitude, otherwise\n   * the animation will start from the wrong position.\n   */\n\n  if (target !== ideal) amplitude = target - from;\n\n  const calcDelta = t => -amplitude * Math.exp(-t / decay);\n\n  const calcLatest = t => target + calcDelta(t);\n\n  const applyFriction = t => {\n    const delta = calcDelta(t);\n    const latest = calcLatest(t);\n    state.done = Math.abs(delta) <= restDistance;\n    state.current = state.done ? target : latest;\n  };\n  /**\n   * Ideally this would resolve for t in a stateless way, we could\n   * do that by always precalculating the animation but as we know\n   * this will be done anyway we can assume that spring will\n   * be discovered during that.\n   */\n\n\n  let timeReachedBoundary;\n  let spring$1;\n\n  const checkCatchBoundary = t => {\n    if (!isOutOfBounds(state.current)) return;\n    timeReachedBoundary = t;\n    spring$1 = spring({\n      from: state.current,\n      to: nearestBoundary(state.current),\n      velocity: calcGeneratorVelocity(calcLatest, t, state.current),\n      damping: bounceDamping,\n      stiffness: bounceStiffness,\n      restDistance,\n      restSpeed\n    });\n  };\n\n  checkCatchBoundary(0);\n  return t => {\n    /**\n     * We need to resolve the friction to figure out if we need a\n     * spring but we don't want to do this twice per frame. So here\n     * we flag if we updated for this frame and later if we did\n     * we can skip doing it again.\n     */\n    let hasUpdatedFrame = false;\n\n    if (!spring$1 && timeReachedBoundary === undefined) {\n      hasUpdatedFrame = true;\n      applyFriction(t);\n      checkCatchBoundary(t);\n    }\n    /**\n     * If we have a spring and the provided t is beyond the moment the friction\n     * animation crossed the min/max boundary, use the spring.\n     */\n\n\n    if (timeReachedBoundary !== undefined && t > timeReachedBoundary) {\n      state.hasReachedTarget = true;\n      return spring$1(t - timeReachedBoundary);\n    } else {\n      state.hasReachedTarget = false;\n      !hasUpdatedFrame && applyFriction(t);\n      return state;\n    }\n  };\n};\n\nexport { glide };","map":null,"metadata":{},"sourceType":"module"}