{"ast":null,"code":"import _slicedToArray from \"/home/hassnain/MERN_APP/RESUME_WEBSITE/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport sync from 'framesync';\nimport React__default, { useContext } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\n\nclass MeasureLayoutWithContext extends React__default.Component {\n  /**\n   * This only mounts projection nodes for components that\n   * need measuring, we might want to do it for all components\n   * in order to incorporate transforms\n   */\n  componentDidMount() {\n    const _this$props = this.props,\n          visualElement = _this$props.visualElement,\n          layoutGroup = _this$props.layoutGroup,\n          switchLayoutGroup = _this$props.switchLayoutGroup,\n          layoutId = _this$props.layoutId;\n    const projection = visualElement.projection;\n    addScaleCorrector(defaultScaleCorrectors);\n\n    if (projection) {\n      if (layoutGroup.group) layoutGroup.group.add(projection);\n\n      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n        switchLayoutGroup.register(projection);\n      }\n\n      projection.root.didUpdate();\n      projection.addEventListener(\"animationComplete\", () => {\n        this.safeToRemove();\n      });\n      projection.setOptions({ ...projection.options,\n        onExitComplete: () => this.safeToRemove()\n      });\n    }\n\n    globalProjectionState.hasEverUpdated = true;\n  }\n\n  getSnapshotBeforeUpdate(prevProps) {\n    const _this$props2 = this.props,\n          layoutDependency = _this$props2.layoutDependency,\n          visualElement = _this$props2.visualElement,\n          drag = _this$props2.drag,\n          isPresent = _this$props2.isPresent;\n    const projection = visualElement.projection;\n    if (!projection) return null;\n    /**\n     * TODO: We use this data in relegate to determine whether to\n     * promote a previous element. There's no guarantee its presence data\n     * will have updated by this point - if a bug like this arises it will\n     * have to be that we markForRelegation and then find a new lead some other way,\n     * perhaps in didUpdate\n     */\n\n    projection.isPresent = isPresent;\n\n    if (drag || prevProps.layoutDependency !== layoutDependency || layoutDependency === undefined) {\n      projection.willUpdate();\n    } else {\n      this.safeToRemove();\n    }\n\n    if (prevProps.isPresent !== isPresent) {\n      if (isPresent) {\n        projection.promote();\n      } else if (!projection.relegate()) {\n        /**\n         * If there's another stack member taking over from this one,\n         * it's in charge of the exit animation and therefore should\n         * be in charge of the safe to remove. Otherwise we call it here.\n         */\n        sync.postRender(() => {\n          var _a;\n\n          if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {\n            this.safeToRemove();\n          }\n        });\n      }\n    }\n\n    return null;\n  }\n\n  componentDidUpdate() {\n    const projection = this.props.visualElement.projection;\n\n    if (projection) {\n      projection.root.didUpdate();\n\n      if (!projection.currentAnimation && projection.isLead()) {\n        this.safeToRemove();\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    const _this$props3 = this.props,\n          visualElement = _this$props3.visualElement,\n          layoutGroup = _this$props3.layoutGroup,\n          promoteContext = _this$props3.switchLayoutGroup;\n    const projection = visualElement.projection;\n\n    if (projection) {\n      projection.scheduleCheckAfterUnmount();\n      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group) layoutGroup.group.remove(projection);\n      if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister) promoteContext.deregister(projection);\n    }\n  }\n\n  safeToRemove() {\n    const safeToRemove = this.props.safeToRemove;\n    safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();\n  }\n\n  render() {\n    return null;\n  }\n\n}\n\nfunction MeasureLayout(props) {\n  const _usePresence = usePresence(),\n        _usePresence2 = _slicedToArray(_usePresence, 2),\n        isPresent = _usePresence2[0],\n        safeToRemove = _usePresence2[1];\n\n  const layoutGroup = useContext(LayoutGroupContext);\n  return React__default.createElement(MeasureLayoutWithContext, { ...props,\n    layoutGroup: layoutGroup,\n    switchLayoutGroup: useContext(SwitchLayoutGroupContext),\n    isPresent: isPresent,\n    safeToRemove: safeToRemove\n  });\n}\n\nconst defaultScaleCorrectors = {\n  borderRadius: { ...correctBorderRadius,\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  },\n  borderTopLeftRadius: correctBorderRadius,\n  borderTopRightRadius: correctBorderRadius,\n  borderBottomLeftRadius: correctBorderRadius,\n  borderBottomRightRadius: correctBorderRadius,\n  boxShadow: correctBoxShadow\n};\nexport { MeasureLayout };","map":null,"metadata":{},"sourceType":"module"}