{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar resolveElements = require('../utils/resolve-elements.cjs.js');\n\nvar utils = require('@motionone/utils');\n\nconst thresholds = {\n  any: 0,\n  all: 1\n};\n\nfunction inView(elementOrSelector, onStart, {\n  root,\n  margin: rootMargin,\n  amount = \"any\"\n} = {}) {\n  /**\n   * If this browser doesn't support IntersectionObserver, return a dummy stop function.\n   * Default triggering of onStart is tricky - it could be used for starting/stopping\n   * videos, lazy loading content etc. We could provide an option to enable a fallback, or\n   * provide a fallback callback option.\n   */\n  if (typeof IntersectionObserver === \"undefined\") {\n    return () => {};\n  }\n\n  const elements = resolveElements.resolveElements(elementOrSelector);\n  const activeIntersections = new WeakMap();\n\n  const onIntersectionChange = entries => {\n    entries.forEach(entry => {\n      const onEnd = activeIntersections.get(entry.target);\n      /**\n       * If there's no change to the intersection, we don't need to\n       * do anything here.\n       */\n\n      if (entry.isIntersecting === Boolean(onEnd)) return;\n\n      if (entry.isIntersecting) {\n        const newOnEnd = onStart(entry);\n\n        if (utils.isFunction(newOnEnd)) {\n          activeIntersections.set(entry.target, newOnEnd);\n        } else {\n          observer.unobserve(entry.target);\n        }\n      } else if (onEnd) {\n        onEnd(entry);\n        activeIntersections.delete(entry.target);\n      }\n    });\n  };\n\n  const observer = new IntersectionObserver(onIntersectionChange, {\n    root,\n    rootMargin,\n    threshold: typeof amount === \"number\" ? amount : thresholds[amount]\n  });\n  elements.forEach(element => observer.observe(element));\n  return () => observer.disconnect();\n}\n\nexports.inView = inView;","map":null,"metadata":{},"sourceType":"script"}